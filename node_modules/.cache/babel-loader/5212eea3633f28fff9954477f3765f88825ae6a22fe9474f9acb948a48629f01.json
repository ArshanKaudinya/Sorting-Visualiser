{"ast":null,"code":"// MERGE SORT\nexport const mergeSort=array=>{if(array.length<=1)return array;const animations=[];mergeSortHelper(array,0,array.length-1,array.slice(),animations);return animations;};const mergeSortHelper=(mainArray,startIdx,endIdx,auxArray,animations)=>{if(startIdx===endIdx)return;const midIdx=Math.floor((startIdx+endIdx)/2);mergeSortHelper(auxArray,startIdx,midIdx,mainArray,animations);mergeSortHelper(auxArray,midIdx+1,endIdx,mainArray,animations);merge(mainArray,startIdx,midIdx,endIdx,auxArray,animations);};const merge=(mainArray,startIdx,midIdx,endIdx,auxArray,animations)=>{let k=startIdx,i=startIdx,j=midIdx+1;while(i<=midIdx||j<=endIdx){if(j>endIdx||i<=midIdx&&auxArray[i]<=auxArray[j]){animations.push({type:'comparison1',indices:[i,j]});animations.push({type:'swap',indices:[k,auxArray[i]]});mainArray[k++]=auxArray[i++];}else{animations.push({type:'comparison2',indices:[i,j]});animations.push({type:'swap',indices:[k,auxArray[j]]});mainArray[k++]=auxArray[j++];}}};// BUBBLE SORT\nexport const bubbleSort=array=>{const animations=[];const n=array.length;let swapped;for(let i=0;i<n-1;i++){swapped=false;for(let j=0;j<n-i-1;j++){// Color change for comparison\nanimations.push({type:'comparison1',indices:[j,j+1]});animations.push({type:'comparison2',indices:[j,j+1]});if(array[j]>array[j+1]){// Swap elements and push the swap animation\nanimations.push({type:'swap',indices:[j,array[j+1]]});animations.push({type:'swap',indices:[j+1,array[j]]});// Perform the swap\nlet temp=array[j];array[j]=array[j+1];array[j+1]=temp;swapped=true;}}// If no elements were swapped, the array is sorted\nif(!swapped)break;}return animations;};","map":{"version":3,"names":["mergeSort","array","length","animations","mergeSortHelper","slice","mainArray","startIdx","endIdx","auxArray","midIdx","Math","floor","merge","k","i","j","push","type","indices","bubbleSort","n","swapped","temp"],"sources":["C:/Users/kaudi/Desktop/sorting-visualiser/src/components/Sorting Algorithms.js"],"sourcesContent":["// MERGE SORT\r\nexport const mergeSort = (array) => {\r\n    if (array.length <= 1) return array;\r\n    const animations = [];\r\n    mergeSortHelper(array, 0, array.length - 1, array.slice(), animations);\r\n    return animations;\r\n};\r\n\r\nconst mergeSortHelper = (mainArray, startIdx, endIdx, auxArray, animations) => {\r\n    if (startIdx === endIdx) return;\r\n    const midIdx = Math.floor((startIdx + endIdx) / 2);\r\n    mergeSortHelper(auxArray, startIdx, midIdx, mainArray, animations);\r\n    mergeSortHelper(auxArray, midIdx + 1, endIdx, mainArray, animations);\r\n    merge(mainArray, startIdx, midIdx, endIdx, auxArray, animations);\r\n};\r\n\r\nconst merge = (mainArray, startIdx, midIdx, endIdx, auxArray, animations) => {\r\n    let k = startIdx, i = startIdx, j = midIdx + 1;\r\n\r\n    while (i <= midIdx || j <= endIdx) {\r\n        if (j > endIdx || (i <= midIdx && auxArray[i] <= auxArray[j])) {\r\n            animations.push({ type: 'comparison1', indices: [i, j] });\r\n            animations.push({ type: 'swap', indices: [k, auxArray[i]] });\r\n            mainArray[k++] = auxArray[i++];\r\n        } else {\r\n            animations.push({ type: 'comparison2', indices: [i, j] });\r\n            animations.push({ type: 'swap', indices: [k, auxArray[j]] });\r\n            mainArray[k++] = auxArray[j++];\r\n        }\r\n    }\r\n};\r\n\r\n// BUBBLE SORT\r\nexport const bubbleSort = (array) => {\r\n    const animations = [];\r\n    const n = array.length;\r\n    let swapped;\r\n\r\n    for (let i = 0; i < n - 1; i++) {\r\n        swapped = false;\r\n        for (let j = 0; j < n - i - 1; j++) {\r\n            // Color change for comparison\r\n            animations.push({ type: 'comparison1', indices: [j, j + 1] });\r\n            animations.push({ type: 'comparison2', indices: [j, j + 1] });\r\n\r\n            if (array[j] > array[j + 1]) {\r\n                // Swap elements and push the swap animation\r\n                animations.push({ type: 'swap', indices: [j, array[j + 1]] });\r\n                animations.push({ type: 'swap', indices: [j + 1, array[j]] });\r\n\r\n                // Perform the swap\r\n                let temp = array[j];\r\n                array[j] = array[j + 1];\r\n                array[j + 1] = temp;\r\n\r\n                swapped = true;\r\n            }\r\n        }\r\n        // If no elements were swapped, the array is sorted\r\n        if (!swapped) break;\r\n    }\r\n\r\n    return animations;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}